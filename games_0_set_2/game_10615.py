import gymnasium as gym
import os
import pygame
import os
import pygame

os.environ.setdefault("SDL_VIDEODRIVER", "dummy")


# Generated: 2025-08-26T14:46:18.298376
# Source Brief: brief_00615.md
# Brief Index: 615
# """import gymnasium as gym
from gymnasium.spaces import MultiDiscrete
import numpy as np
import pygame
import pygame.gfxdraw
import math
import random

class GameEnv(gym.Env):
    """
    Gymnasium environment for 'Leviathan's Lair'.

    The player deploys and upgrades magnetic collectors through portals to map a
    leviathan's lair. The core challenge is to manage a central energy pool,
    which is generated by collectors but drained by periodic leviathan attacks.
    Collectors placed closer to the center map the area faster but are more
    vulnerable to attacks. The game ends in victory if the map is fully
    revealed, or in defeat if the energy runs out.
    """
    metadata = {"render_modes": ["rgb_array"]}

    game_description = (
        "Deploy and upgrade magnetic collectors to map a leviathan's lair. "
        "Manage your energy against periodic attacks to reveal the entire map before your power runs out."
    )
    user_guide = (
        "Controls: Use arrow keys (↑↓←→) to select a portal. Press space to deploy a collector and shift to upgrade an existing one."
    )
    auto_advance = True

    # --- Constants ---
    SCREEN_WIDTH, SCREEN_HEIGHT = 640, 400
    FPS = 30
    MAX_EPISODE_STEPS = 5000

    # Colors
    COLOR_BG = (5, 10, 30)
    COLOR_PORTAL = (0, 255, 255)
    COLOR_PORTAL_SELECTED = (255, 255, 0)
    COLOR_COLLECTOR_L1 = (0, 255, 100)
    COLOR_COLLECTOR_L2 = (150, 255, 0)
    COLOR_COLLECTOR_L3 = (255, 200, 0)
    COLLECTOR_COLORS = [COLOR_COLLECTOR_L1, COLOR_COLLECTOR_L2, COLOR_COLLECTOR_L3]
    COLOR_LEVIATHAN_ATTACK = (255, 20, 20)
    COLOR_UI_TEXT = (220, 220, 240)
    COLOR_ENERGY_HIGH = (0, 255, 120)
    COLOR_ENERGY_MID = (255, 255, 0)
    COLOR_ENERGY_LOW = (255, 50, 50)
    COLOR_MAP_REVEAL = (0, 100, 200)

    # Game Mechanics
    MAX_ENERGY = 100.0
    INITIAL_ENERGY = 50.0
    DEPLOY_COST = 20.0
    UPGRADE_BASE_COST = 30.0
    TARGET_MAP_VALUE = 25000.0
    
    def __init__(self, render_mode="rgb_array"):
        super().__init__()

        # Gymnasium spaces
        self.observation_space = gym.spaces.Box(
            low=0, high=255, shape=(self.SCREEN_HEIGHT, self.SCREEN_WIDTH, 3), dtype=np.uint8
        )
        self.action_space = MultiDiscrete([5, 2, 2])
        
        # Pygame setup
        pygame.init()
        pygame.font.init()
        self.screen = pygame.Surface((self.SCREEN_WIDTH, self.SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        try:
            self.font_small = pygame.font.SysFont("Consolas", 16)
            self.font_large = pygame.font.SysFont("Consolas", 24, bold=True)
        except pygame.error:
            self.font_small = pygame.font.Font(None, 20)
            self.font_large = pygame.font.Font(None, 30)

        # Game state variables are initialized in reset()
        self.portals = []
        self.collectors = []
        self.particles = []
        self.leviathan_attacks = []
        self.background_flora = []
        self.map_surface = None
        self.selected_portal_idx = 0
        self.energy = 0
        self.total_map_value = 0
        self.mapped_percentage = 0
        self.leviathan_attack_timer = 0
        self.leviathan_attack_interval = 0
        self.leviathan_attack_damage_multiplier = 0
        self.steps = 0
        self.score = 0
        self.game_over = False

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)

        # Initialize game state
        self.energy = self.INITIAL_ENERGY
        self.total_map_value = 0.0
        self.mapped_percentage = 0.0
        self.steps = 0
        self.score = 0
        self.game_over = False
        self.selected_portal_idx = 0
        
        center_x, center_y = self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2
        dist_x, dist_y = 180, 100
        self.portals = [
            {'pos': (center_x - dist_x, center_y - dist_y), 'collector_id': None},
            {'pos': (center_x + dist_x, center_y - dist_y), 'collector_id': None},
            {'pos': (center_x - dist_x, center_y + dist_y), 'collector_id': None},
            {'pos': (center_x + dist_x, center_y + dist_y), 'collector_id': None},
        ]
        self.collectors = []
        
        self.particles = []
        self.leviathan_attacks = []
        
        self.map_surface = pygame.Surface((self.SCREEN_WIDTH, self.SCREEN_HEIGHT), pygame.SRCALPHA)
        self.map_surface.fill((0, 0, 0, 0))

        self._update_difficulty()
        self.leviathan_attack_timer = self.leviathan_attack_interval

        if not self.background_flora:
            for _ in range(100):
                self.background_flora.append(self._create_flora_particle())

        return self._get_observation(), self._get_info()

    def step(self, action):
        if self.game_over:
            return self._get_observation(), 0, True, False, self._get_info()

        self.steps += 1
        reward = 0.0
        
        # --- 1. Handle Input ---
        self._handle_input(action)
        
        # --- 2. Update Game Logic ---
        # Update collectors (energy gen, mapping)
        energy_generated = 0
        map_value_gained = 0
        for collector in self.collectors:
            energy_generated += 0.05 * collector['level']
            
            dist_to_center = math.hypot(
                collector['pos'][0] - self.SCREEN_WIDTH / 2,
                collector['pos'][1] - self.SCREEN_HEIGHT / 2
            )
            # Closer collectors map faster
            map_value_gained += (2.0 * collector['level']) / max(10, dist_to_center / 10)
            
            # Collector pulse animation
            collector['pulse'] = (collector['pulse'] + 0.1) % (2 * math.pi)

        # Update main energy and map values
        self.energy = min(self.MAX_ENERGY, self.energy + energy_generated)
        self.total_map_value += map_value_gained
        
        old_map_pct = self.mapped_percentage
        self.mapped_percentage = min(100.0, (self.total_map_value / self.TARGET_MAP_VALUE) * 100.0)
        
        # Update difficulty based on progress
        self._update_difficulty()

        # Update Leviathan
        self.leviathan_attack_timer -= 1
        if self.leviathan_attack_timer <= 0:
            # --- Leviathan Attack ---
            # sfx: deep_rumble.wav
            self.leviathan_attack_timer = self.leviathan_attack_interval
            self.leviathan_attacks.append({
                'radius': 0, 'max_radius': self.SCREEN_WIDTH, 'life': 60
            })
            
            total_damage = 0
            for collector in self.collectors:
                dist_to_center = math.hypot(
                    collector['pos'][0] - self.SCREEN_WIDTH / 2,
                    collector['pos'][1] - self.SCREEN_HEIGHT / 2
                )
                # Damage is higher for closer collectors
                damage = (self.leviathan_attack_damage_multiplier * 150) / max(1, dist_to_center)
                total_damage += damage
                # sfx: zap_or_energy_drain.wav
                self._create_damage_particles(collector['pos'])

            self.energy -= total_damage
        
        # --- 3. Update Visuals & Particles ---
        self._update_particles()
        self._update_map_surface()

        # --- 4. Calculate Reward ---
        # Continuous rewards
        reward += (self.mapped_percentage - old_map_pct) * 0.1 # +0.1 per 1% map revealed
        reward += energy_generated * 0.01

        # Event-based rewards (handled in _handle_input)
        reward += self.deploy_reward_this_step
        self.deploy_reward_this_step = 0 # Reset for next step
        
        # --- 5. Check Termination ---
        terminated = False
        truncated = False
        if self.energy <= 0:
            self.energy = 0
            reward = -100.0
            terminated = True
            self.game_over = True
        elif self.mapped_percentage >= 100:
            reward = 100.0
            terminated = True
            self.game_over = True
        elif self.steps >= self.MAX_EPISODE_STEPS:
            truncated = True
            self.game_over = True
            
        self.score += reward

        return (
            self._get_observation(),
            reward,
            terminated,
            truncated,
            self._get_info()
        )

    def _handle_input(self, action):
        movement, space_pressed, shift_pressed = action[0], action[1] == 1, action[2] == 1
        self.deploy_reward_this_step = 0

        # Update selected portal based on movement
        if movement == 1: # Up
            self.selected_portal_idx = self.selected_portal_idx % 2
        elif movement == 2: # Down
            self.selected_portal_idx = 2 + (self.selected_portal_idx % 2)
        elif movement == 3: # Left
            self.selected_portal_idx = 0 if self.selected_portal_idx in [0, 2] else 2
        elif movement == 4: # Right
            self.selected_portal_idx = 1 if self.selected_portal_idx in [1, 3] else 3
        
        selected_portal = self.portals[self.selected_portal_idx]

        # Prioritize Upgrade -> Deploy
        if shift_pressed:
            # Upgrade action
            if selected_portal['collector_id'] is not None:
                collector = next((c for c in self.collectors if c['id'] == selected_portal['collector_id']), None)
                if collector and collector['level'] < 3:
                    upgrade_cost = self.UPGRADE_BASE_COST * collector['level']
                    if self.energy >= upgrade_cost:
                        self.energy -= upgrade_cost
                        collector['level'] += 1
                        # sfx: upgrade_success.wav
                        self._create_upgrade_particles(collector['pos'])

        elif space_pressed:
            # Deploy action
            if selected_portal['collector_id'] is None:
                if self.energy >= self.DEPLOY_COST:
                    self.energy -= self.DEPLOY_COST
                    new_id = len(self.collectors)
                    new_collector = {
                        'id': new_id,
                        'pos': selected_portal['pos'],
                        'level': 1,
                        'pulse': random.uniform(0, 2 * math.pi)
                    }
                    self.collectors.append(new_collector)
                    selected_portal['collector_id'] = new_id
                    self.deploy_reward_this_step = 1.0 # Event-based reward
                    # sfx: deploy.wav
                    self._create_deploy_particles(new_collector['pos'])

    def _update_difficulty(self):
        progress_tier = int(self.mapped_percentage // 20) # 0-5
        self.leviathan_attack_damage_multiplier = 1.0 + (progress_tier * 0.5)
        self.leviathan_attack_interval = max(self.FPS * 2, self.FPS * (5.0 - progress_tier * 0.75))

    def _get_observation(self):
        # Clear screen
        self.screen.fill(self.COLOR_BG)
        
        # Render background
        self._render_background_flora()

        # Render revealed map area
        self.screen.blit(self.map_surface, (0, 0))

        # Render leviathan attacks
        self._render_leviathan_attacks()
        
        # Render particles
        self._render_particles()

        # Render portals and collectors
        self._render_portals_and_collectors()
        
        # Render UI
        self._render_ui()
        
        # Convert to numpy array
        arr = pygame.surfarray.array3d(self.screen)
        return np.transpose(arr, (1, 0, 2)).astype(np.uint8)

    def _get_info(self):
        return {
            "score": self.score,
            "steps": self.steps,
            "energy": self.energy,
            "map_percentage": self.mapped_percentage,
            "collectors": len(self.collectors),
        }

    # --- Rendering Methods ---

    def _render_background_flora(self):
        for p in self.background_flora:
            p['life'] -= 1
            if p['life'] <= 0:
                p.update(self._create_flora_particle())
            
            alpha = int(math.sin(p['life'] / p['max_life'] * math.pi) * p['max_alpha'])
            color = (*p['color'], alpha)
            pygame.gfxdraw.filled_circle(self.screen, int(p['pos'][0]), int(p['pos'][1]), int(p['radius']), color)

    def _render_leviathan_attacks(self):
        center = (self.SCREEN_WIDTH // 2, self.SCREEN_HEIGHT // 2)
        for attack in self.leviathan_attacks:
            alpha = int(max(0, (attack['life'] / 60)) * 100)
            color = (*self.COLOR_LEVIATHAN_ATTACK, alpha)
            pygame.gfxdraw.aacircle(self.screen, center[0], center[1], int(attack['radius']), color)
            if attack['radius'] > 10:
                pygame.gfxdraw.aacircle(self.screen, center[0], center[1], int(attack['radius'] - 10), color)

    def _render_particles(self):
        for p in self.particles:
            alpha = int(p['alpha'] * (p['life'] / p['max_life']))
            if alpha > 0:
                color = (*p['color'], alpha)
                pygame.gfxdraw.filled_circle(self.screen, int(p['pos'][0]), int(p['pos'][1]), int(p['radius']), color)

    def _render_portals_and_collectors(self):
        for i, portal in enumerate(self.portals):
            pos = (int(portal['pos'][0]), int(portal['pos'][1]))
            pulse = math.sin(self.steps * 0.05 + i) * 2
            
            # Draw portal ring
            is_selected = (i == self.selected_portal_idx)
            color = self.COLOR_PORTAL_SELECTED if is_selected else self.COLOR_PORTAL
            self._draw_glowing_circle(self.screen, color, pos, 15 + pulse, glow_factor=1.5, glow_alpha=40)
            pygame.gfxdraw.filled_circle(self.screen, pos[0], pos[1], 12, self.COLOR_BG)

            # Draw collector if it exists
            if portal['collector_id'] is not None:
                collector = next((c for c in self.collectors if c['id'] == portal['collector_id']), None)
                if collector:
                    collector_pulse = math.sin(collector['pulse']) * 2
                    level_idx = min(len(self.COLLECTOR_COLORS) - 1, collector['level'] - 1)
                    collector_color = self.COLLECTOR_COLORS[level_idx]
                    self._draw_glowing_circle(self.screen, collector_color, pos, 10 + collector_pulse, glow_factor=2.5, glow_alpha=80)
                    
                    # Draw level indicator
                    for l in range(collector['level']):
                        angle = (2 * math.pi / 3) * l - math.pi / 2
                        lx = pos[0] + math.cos(angle) * (18 + pulse)
                        ly = pos[1] + math.sin(angle) * (18 + pulse)
                        pygame.gfxdraw.filled_circle(self.screen, int(lx), int(ly), 2, self.COLOR_UI_TEXT)

    def _render_ui(self):
        # Energy Bar
        bar_width, bar_height = 200, 20
        bar_x, bar_y = self.SCREEN_WIDTH / 2 - bar_width / 2, 15
        energy_ratio = self.energy / self.MAX_ENERGY
        
        if energy_ratio > 0.5:
            bar_color = self.COLOR_ENERGY_HIGH
        elif energy_ratio > 0.2:
            bar_color = self.COLOR_ENERGY_MID
        else:
            bar_color = self.COLOR_ENERGY_LOW

        pygame.draw.rect(self.screen, (50, 50, 70), (bar_x - 2, bar_y - 2, bar_width + 4, bar_height + 4), border_radius=5)
        pygame.draw.rect(self.screen, self.COLOR_BG, (bar_x, bar_y, bar_width, bar_height), border_radius=5)
        if energy_ratio > 0:
            pygame.draw.rect(self.screen, bar_color, (bar_x, bar_y, bar_width * energy_ratio, bar_height), border_radius=5)

        # Map Percentage Text
        map_text = f"LAIR MAPPED: {self.mapped_percentage:.1f}%"
        self._draw_text(map_text, (self.SCREEN_WIDTH / 2, 50), self.font_small, self.COLOR_UI_TEXT)

        if self.game_over:
            overlay = pygame.Surface((self.SCREEN_WIDTH, self.SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 150))
            self.screen.blit(overlay, (0,0))
            
            end_text = "MAP COMPLETE" if self.mapped_percentage >= 100 else "ENERGY DEPLETED"
            self._draw_text(end_text, (self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2 - 20), self.font_large, self.COLOR_UI_TEXT)
            self._draw_text(f"Final Score: {self.score:.0f}", (self.SCREEN_WIDTH / 2, self.SCREEN_HEIGHT / 2 + 20), self.font_small, self.COLOR_UI_TEXT)

    # --- Particle and Effect Helpers ---

    def _create_flora_particle(self):
        return {
            'pos': (random.uniform(0, self.SCREEN_WIDTH), random.uniform(0, self.SCREEN_HEIGHT)),
            'radius': random.uniform(1, 3),
            'color': random.choice([(0, 50, 100), (20, 0, 80), (0, 60, 60)]),
            'life': random.uniform(self.FPS * 2, self.FPS * 5),
            'max_life': self.FPS * 5,
            'max_alpha': random.uniform(20, 50)
        }

    def _update_particles(self):
        self.particles = [p for p in self.particles if p['life'] > 0]
        for p in self.particles:
            p['life'] -= 1
            p['pos'] = (p['pos'][0] + p['vel'][0], p['pos'][1] + p['vel'][1])
            p['radius'] *= 0.98

        self.leviathan_attacks = [a for a in self.leviathan_attacks if a['life'] > 0]
        for a in self.leviathan_attacks:
            a['life'] -= 1
            a['radius'] += (a['max_radius'] - a['radius']) * 0.05

    def _create_effect_particles(self, pos, count, color, speed, life, alpha):
        for _ in range(count):
            angle = random.uniform(0, 2 * math.pi)
            vel = (math.cos(angle) * speed, math.sin(angle) * speed)
            self.particles.append({
                'pos': list(pos), 'vel': vel, 'radius': random.uniform(2, 5),
                'color': color, 'life': life, 'max_life': life, 'alpha': alpha
            })

    def _create_deploy_particles(self, pos):
        self._create_effect_particles(pos, 30, self.COLOR_PORTAL, 2, 20, 150)

    def _create_upgrade_particles(self, pos):
        self._create_effect_particles(pos, 20, self.COLOR_PORTAL_SELECTED, 3, 25, 200)

    def _create_damage_particles(self, pos):
        self._create_effect_particles(pos, 10, self.COLOR_LEVIATHAN_ATTACK, 1.5, 15, 255)

    def _update_map_surface(self):
        for collector in self.collectors:
            dist_to_center = math.hypot(
                collector['pos'][0] - self.SCREEN_WIDTH / 2,
                collector['pos'][1] - self.SCREEN_HEIGHT / 2
            )
            # Closer collectors reveal a larger radius
            reveal_radius = int(1000 / max(10, dist_to_center)) * collector['level']
            alpha = int(min(2.5, (self.mapped_percentage / 20)))
            color = (*self.COLOR_MAP_REVEAL, alpha)
            pygame.gfxdraw.filled_circle(self.map_surface, int(collector['pos'][0]), int(collector['pos'][1]), reveal_radius, color)

    # --- Drawing Helpers ---

    def _draw_glowing_circle(self, surface, color, pos, radius, glow_factor=2.0, glow_alpha=60):
        glow_radius = int(radius * glow_factor)
        glow_color = (*color, glow_alpha)
        pygame.gfxdraw.filled_circle(surface, pos[0], pos[1], glow_radius, glow_color)
        pygame.gfxdraw.aacircle(surface, pos[0], pos[1], glow_radius, glow_color)
        pygame.gfxdraw.filled_circle(surface, pos[0], pos[1], int(radius), color)
        pygame.gfxdraw.aacircle(surface, pos[0], pos[1], int(radius), color)

    def _draw_text(self, text, pos, font, color, align="center"):
        text_surface = font.render(text, True, color)
        text_rect = text_surface.get_rect()
        if align == "center":
            text_rect.center = pos
        elif align == "topleft":
            text_rect.topleft = pos
        self.screen.blit(text_surface, text_rect)

    def close(self):
        pygame.quit()

if __name__ == '__main__':
    # --- Manual Play Example ---
    # This block will not run in the headless testing environment.
    # It is for local testing with a display.
    os.environ.pop("SDL_VIDEODRIVER", None)
    
    env = GameEnv()
    obs, info = env.reset()
    done = False
    
    # Pygame setup for manual play
    render_screen = pygame.display.set_mode((GameEnv.SCREEN_WIDTH, GameEnv.SCREEN_HEIGHT))
    pygame.display.set_caption("Leviathan's Lair")
    clock = pygame.time.Clock()
    
    total_reward = 0
    
    print("\n--- Controls ---")
    print(GameEnv.user_guide)
    print("Q: Quit")
    print("----------------\n")
    
    running = True
    while running:
        # Action defaults
        movement_action = 0 # No-op
        space_action = 0 # Released
        shift_action = 0 # Released

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        
        keys = pygame.key.get_pressed()
        if keys[pygame.K_q]:
            running = False
            
        if keys[pygame.K_UP]: movement_action = 1
        elif keys[pygame.K_DOWN]: movement_action = 2
        elif keys[pygame.K_LEFT]: movement_action = 3
        elif keys[pygame.K_RIGHT]: movement_action = 4
        
        if keys[pygame.K_SPACE]: space_action = 1
        if keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]: shift_action = 1

        action = [movement_action, space_action, shift_action]
        
        obs, reward, terminated, truncated, info = env.step(action)
        total_reward += reward
        
        if terminated or truncated:
            print(f"Game Over! Final Info: {info}")
            print(f"Total Reward: {total_reward}")
            obs, info = env.reset()
            total_reward = 0
            pygame.time.wait(2000) # Pause before restarting

        # Render the observation to the display
        surf = pygame.surfarray.make_surface(np.transpose(obs, (1, 0, 2)))
        render_screen.blit(surf, (0, 0))
        pygame.display.flip()
        
        clock.tick(env.FPS)
        
    env.close()